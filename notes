############## mod 8 lesson 1 ##################
################ Libraries ################### 

image saved m8l1_1

libraries are resources that contain code and/or data.
Libraries are referenced by new programs via a process known as linking. Libraries are linked statically or dynamically. Static linking copies all the referenced portions of the library into the resulting program image, while dynamic linking references the library instead of copying the library.


On Windows, libraries that are intended to be statically linked use the .lib file extension by convention. Linux prepends these files with lib and the file ending with .a. Since static libraries are copied to, and included in, the resulting binary at compile time, updating these libraries generally requires recompiling the program.


On Windows, dynamic libraries use the .dll file extension by convention; Linux uses .so. These libraries are stored externally to the application, so they can be updated independently of the executable that uses them.

On Windows, dynamic libraries can be found in various places. Libraries shared by multiple applications might exist in a specific shared library, like an installation in C:\Program Files\ or by convention by the library provider.
Libraries are also found in an application’s directory or in Windows system folders like System32.

Windows systems, there are various readily available programs to view modules (libraries) loaded by processes including Process Explorer, Process Hacker, PowerShell’s Get-Process cmdlet, etc.

SafeSearch Order:
 Directory application is located in
System directory (typically C:\Windows\System32)
16-bit System directory (typically C:\Windows\System)
Windows directory (typically C:\Windows\)
Current working directory
Directories listed in PATH environment variable


Examining Libraries ##########################

Analyst toolkits include many tools for viewing and interacting with dynamic libraries. There are several classes of tools for analyzing libraries and executables, such as:
- Decompiler: Attempts to reconstruct a library or program executable into source code that can be compiled into the same assembly. May require formatting and relabeling code in order to be comprehensible.

- Portable Executable (PE) Header/Metadata Analyzer: Examines the headers and other structures of an assembly to reveal information about the assembly, such as its dependencies and extracting resources from the 
file.
- String Analyzer/Dumper: Dumps all strings contained in an assembly for analysis.
- Disassembler: Breaks down native libraries into readable assembly code for analyzing behavior of a library or executable.
- Hex Editor: Allows viewing and editing of raw binaries; displays data using hexadecimal. Often contains the ability to view binary as various data formats, such as strings or integers.

Attacks Involving Libraries #######################
MITRE Adversarial Tactics, Techniques, and Common Knowledge (ATT&CK) Framework ########################

MITRE lists many Techniques, Tactics, and Procedures (TTP) that attackers use libraries in order to execute. A selection of these TTPs is covered, or use MITRE ATT&CK Navigator to explore TTPs, including those that are not covered here.

Dynamic libraries are used to achieve an attacker’s goal, including:
- Persistence
- Privilege Escalation
- Defense Evasion

The following techniques are used to accomplish one or more of the above tactics:

T1546.10: Event Triggered Execution: AppInit DLLs
Causes a library to be loaded any time an application that references User32.dll is executed, which encompasses most applications — allowing persistence. DllMain entries are used to execute code under that application’s context, which potentially allows for privilege escalation.

T1055.001: Process Injection: DLL Injection
DLL Injection: Attach to another process, then load a specified library — triggering the execution of code under that process’s context. This allows for privilege

T1574.002: Hijack Execution Flow: DLL Side-Loading
DLL Side-Loading: Application manifest files describe the version of a library that is loaded. If this manifest is vague or imprecise, an attacker can exploit this weakness to load a malicious library instead of the intended library. This allows an attacker to gain persistence by hijacking a common process, some defense evasion by its nature of executing under a trusted process, and a potential for privilege escalation if the process has elevated permissions.

T1574.001: Hijack Execution Flow: DLL Search Order Hijacking
Hijack Execution Flow: DLL Load Order attack takes advantage of weaknesses in some applications and the order of paths those libraries are loaded from. An attacker creates a malicious DLL that replaces a DLL expected by the application and executes code under the context of that application, allowing the attacker to potentially become persistent, escalate privileges, or evade defenses.

T1574.006: Hijack Execution Flow: LD_PRELOAD
LD_PRELOAD: A shared library attack for Linux that allows an attacker to override which library loads when a process loads a specific library by setting the LD_PRELOAD environment variable 

Detection #######################

Detection for each of these techniques typically involves the detection of libraries being loaded from unusual locations. This behavior is not typically logged by default on modern OSs. The installation of monitoring software is often necessary to detect these attacks, however, some of these methods leave behind artifacts — especially if in current use for persistence — such as:

T1546.010: AppInit DLL
Registry entries, such as HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows\LoadAppInit_DLLs
Malicious library in the path it is loaded from

T1055.001: DLL Injection
Malicious library or libraries used during the attackLoaded by processes

T1574.002: DLL Side-Loading
Malicious library or libraries used during the attack in C:\Windows\WinSXS folder
Library manifests in C:\Windows\WinSXS folder

T1547.004: DLL Load Order
Malicious library in a search path

T1574.006: LD_PRELOAD
Malicious library used during the attack
Persistent environmental variable change to the LD_PRELOAD variable

Detection of currently loaded malicious libraries is accomplished by querying modules loaded by processes on the system and analyzing them. This requires baseline information about the system and other hosts within the organization.

############## mod 8 lesson 2 ##################
################ Libraries ################### 

 process is an executing program — typically based on the Portable Execution (PE) file format 

 process has numerous elements including:
- A private virtual memory space
- An executable program image
- Handles to kernel objects
- A security token
- A unique Process Identifier (PID)
- One or more threads to execute instructions

Windows, memory space is divided into an area that user-mode processes access and a second area that is used exclusively by the kernel and kernel processes. 

32-bit systems, each process is allocated 2 Gigabytes (GB) for its user-mode memory space while the kernel gets 2GB shared across all processes. In 64-bit systems, each process can theoretically be allocated Terabytes (TB) of user-mode memory space while the kernel also gets TBs of memory space across all processes.

Windows Memory Manager, part of the kernel space Executive, decides where each process’s data is mapped in the computer’s physical RAM, or if it is stored on the computer’s hard drive in a process known as Paging.

Paging is the process by which Windows stores infrequently accessed information for processes on a system’s hard drive — in what is known as a paging file


each process receives the same range of addresses within their private virtual memory space, processes are not guaranteed to use the same memory addresses within that private memory space each time they are run. Modern Windows processes take advantage of Address Space Layout Randomization (ASLR). ASLR is a security mechanism that instructs the Windows loader randomize the base memory address of executables and the position of libraries, heap, and the stack in a processes' address space. ASLR is primarily intended to defend against memory-based exploits like buffer overflows by eliminating an exploit’s ability to rely on hardcoded memory addresses. ASLR does not defeat memory based exploits or attacks, but increases the difficulty to reliably gain control of execution, reducing the likelihood of a successful attack.

stack is an area of memory determined at compile time, and is used as storage for temporary variables and functions used by a program. The heap, in contrast, is used to store data that is provided to the process at runtime because the developer cannot anticipate exactly what information is input into the program in advance. 

Notably, in the interest of being memory efficient, system Dynamic Link Libraries (DLL) are shared between processes and commonly mapped to the same locations in virtual memory. Notepad.exe and MicrosoftEdge.exe have the DLL urlmon.dll mapped to the same location,

Any action that involves interaction with a computer’s hardware requires assistance from the kernel. 

When a user logs into Windows, the system generates and associates a security token with that user account. Each process that user starts receives the security token, which includes the identity and privileges of the user account. 

Security tokens contain a range of information, such as the Security Identifier (SID) of the originating user account, the SIDs for the groups which the account is a member, and a list of privileges held by that user or that user’s groups.

Each process, when it is created, receives a unique PID. A PID can be used to locate a running process and create a handle to it, like a kernel object.

A thread has multiple components:
- Memory
- Execution contex
- Thread local storage
- Security token
- Message queue
- Thread ID
- State
- Priority

. Memory can also be dynamically allocated by a thread, which would be in the process’s heap; dynamic memory is shared between threads, while the stack memory is not.

TLS provides a mechanism for a thread to store data relevant only to it — without needing to share that information across other threads.

Like processes, threads also have unique IDs that other applications can use to identify specific threads and create handles pointing to them. A thread ID is only unique for as long as a thread exists; once a thread has finished executing, its ID is relinquished and can be reused by the system for a new thread.

Each thread has a state which represents whether it is currently executing instructions. For example, some states include Ready (meaning the thread is available for the OS to execute it), Standby (meaning the thread has been selected as the next thread to execute), Wait (meaning the thread is currently paused and waiting for an operation to complete or a resource to become free), and Running (meaning the thread is currently executing).


This process is responsible for enforcing security policy on the system, including logon verification, password policy, writing to Windows security logs, and the creation of access tokens. Credentials are often stored in lsass process memory for use by accounts during a login session. Since it contains those credentials, dumping lsass memory is a valued target of threat actors during the following types of attacks:
MITRE ATT&CK OS Credential Dumping: LSASS Memory T1003.001: https://attack.mitre.org/techniques/T1003/001/ MITRE ATT&CK Boot or Logon Autostart Execution: LSASS Driver T1547.008: https://attack.mitre.org/techniques/T1547/008/ MITRE ATT&CK Modify Authentication Process T1556: https://attack.mitre.org/techniques/T1556/ 


This application is used to launch functionality stored in shared DLL files. The valid process is normally located at C:\Windows\System32\rundll32.exe, but sometimes malware uses the same filename and runs from a different directory in order to disguise itself, so determining the executable file path is important if this process is suspect. Additionally, threat actors may abuse the allowlists or false positives from normal operations associated with rundll32.exe to proxy execution of malicious code. By bootstrapping a shared module through rundll32.exe, instead of executing directly, they may avoid defensive mechanism on a system. This method is described further in MITRE technique ID T1218.011 Signed Binary Proxy Execution: Rundll32.


Additional Resources
MITRE ATT&CK Signed Binary Proxy Execution: Rundll32: https://attack.mitre.org/techniques/T1218/011/ MITRE ATT&CK Masquerading: Match Legitimate Name or Location: https://attack.mitre.org/techniques/T1036/005/

############## mod 8 lesson 3 ##################
################ Windows API ################### 

Windows API is the intermediary interface that allows other programs to interact with the Windows OS. It can be used for many things such as manipulating or creating processes, modifying the registry, and enabling network connections. It can be thought of as a collection of predefined functions to do everything that needs to be done within the OS. Each function has specific input requirements and produces specific outputs, but how the function actually performs its task is not publicly documented by the Windows developers


 functions that make up the Windows API — and are used to communicate with the Windows OS — are stored and accessed via Windows library files known as DLLs, which can be grouped into categories, some of which are explained below. Full documentation can be found in the Microsoft documentation. 

System Services: These libraries provide access to Windows file systems, devices, processes and threads, registry, and error handling.Library DLLs:kernel32.dll advapi32.dll ole32.dll

Graphics Device Interface: These libraries provide the functionality for outputting graphical content to monitors, printers, and other output devices.Library DLLs:gdi32.dll

User Interface (UI): These libraries include Common Dialog Box DLLs, which provide functions to create and interface with standard dialog boxes for opening and saving files, choosing color and font, etc.; Common Control Library DLLs, which provide access to status bars, progress bars, toolbars, tabs, and other advanced control features; and Windows Shell DLLs, which provide the functionality and modification of the OS shell.Library DLLs:comctl32.dllcomdlg32.dllshell32.dll  shlwapi.dlluser32.dll

Network Services: These libraries provide access to the various networking capabilities of the OS, including Network Basic Input/Output System (NetBIOS), Windows Sockets (Winsock), Network Dynamic Data Exchange (NetDDE), Remote Procedure Calls (RPC), and many others.Library DLLs:ws2_32.dllwsock32.dllwininet.dllnetapi32.dll

Kernel32.dll: This is a very common DLL that contains core functionality, such as access and manipulation of memory, files, and hardware. Some of the common API calls in this DLL are:
ConnectNamedPipe: Creates a server pipe for interprocess communication that waits for a client pipe to connect. Some backdoors and reverse shells use ConnectNamedPipe to simplify or obfuscate connectivity to a Command and Control (C2) server.
CreateFile: Creates a new file or opens an existing file.
CreateFileMapping: Creates a handle to a file mapping that loads a file into memory and makes it accessible via memory addresses. Launchers, loaders, and injectors use this to read and modify PE files.CreateProcess: Creates and launches a new process. If malware creates a new process, it needs to be analyzed as well.
CreateRemoteThread: Starts a thread in a remote process. Launchers and stealth malware use CreateRemoteThread to inject code into a different process.
numProcesses: Enumerates through running processes on the system. Malware enumerates through processes to find one into which to inject.
EnumProcessModules: Enumerates the loaded modules (executables and DLLs) for a given process. Malware enumerates through modules when performing an injection
GetModuleFilename: Returns the filename of a module loaded in the current process. Malware uses this function to modify or copy files in the currently running process.
GetModuleHandle: Obtains a handle to an already loaded module. Processes use GetModuleHandle to locate and modify code in a loaded module or to search for a good location to inject code.
GetProcAddress: Retrieves the address of a function in a DLL loaded into memory. Imports functions from other DLLs and functions imported in the PE file header.
IsWoW64Process: Used by a 32-bit process to determine if it is running on a 64-bit OS.
LoadLibraryA/LoadLibraryEx: Function to load a DLL into a process.
OpenProcess: Opens a handle to another process running on the system. This handle reads and writes to the other process memory or injects code into the other process.
SetFileTime: Modifies the creation, access, or last modified time of a file. Malware often uses this function to conceal malicious activity.
VirtualAllocEx: A routine that allocates memory in a remote process. Malware uses VirtualAllocEx as part of a process injection.
WriteProcessMemory: Writes data to a remote process. Malware uses WriteProcessMemory as part of a process injection.

Advapi32.dll: This DLL provides access to advanced Windows core components, such as Service Manager and the registry. Some of the common API calls in this DLL are:
AdjustTokenPrivileges: Enables/disables specific access privileges. It allows malware to gain additional permissions in a process injection attack.
ControlService: Starts, stops, modifies, or sends a signal to a running service. Code needs to be analyzed that implements malicious services in order to determine the purpose of the call.
CreateService: Creates a service started at boot time. Malware uses CreateService for persistence, stealth, or to load kernel drivers.
RegCreateKeyEx: Creates a registry key.
RegDeleteKey: Deletes a registry subkey and its values.

WSock32.dll and Ws2_32.dll: These are networking DLLs. A program that accesses either of these most likely connects to a network or performs network-related tasks. Some of the common API calls in this DLL are:
Accept: Listens for incoming connections on a socket. Used by malware to communicate with the C2 server.
Bind: Associates a local address to a socket to listen for incoming connections.
Connect: Connects to a remote socket. Malware often uses low-level functionality to connect to a C2 server. Used by malware to communicate with the C2 server.
inet_addr: Converts an Internet Protocol (IP) address string  — like 127.0.0.1 — to the Windows structure used by other functions, such as Connect. The IP addresses found in these calls — and used in malware —  may be used in network-based signatures to identify potentially malicious activity. 
Recv: Receives data from a remote machine. Used by malware to receive data from a remote C2 server.
Send: Sends data to a remote machine. Used by malware to send data to a remote C2 server.
WSAStartup: Initializes low-level network functionality. Finding calls to WSAStartup is an easy way to locate the start of network-related functionality.

Wininet.dll: This DLL contains higher-level networking functions that implement protocols such as File Transfer Protocol (FTP), Hypertext Transfer Protocol (HTTP), and Network Time Protocol (NTP). Some of the common API calls in this DLL are:
FtpPutFile: Uploads a file to remote FTP server.
InternetOpen: Initializes the high-level internet access functions from Windows Internet (WinINet), such as InternetOpenUrl and InternetReadFile. Searching for InternetOpen is a good way to find the start of internet access functionality. One of the parameters to InternetOpen is the UserAgent, which may be a good network-based signature, if it is unique or not common.
InternetOpenUrl: Opens a specific Uniform Resource Locator (URL) for a connection using FTP, HTTP, or Hypertext Transfer Protocol Secure (HTTPS). URLs, if fixed, may be good network-based signatures.
InternetReadFile: Reads data from a previously opened URL.
InternetWriteFile: Writes data to a previously opened URL.

Ntdll.dll: The interface to the Windows kernel. Importing this DLL is one way that one can gain access to the undocumented Windows Native API.



 The -r option is normally identical to the normal output as seen in Figure 8.3-15. The output changes if the DLL is loaded from a relocated module — below is an example of what would change in the listdlls output:

 ### Relocated from base of 0x00000000a8270000:
 [base] [size] [path of relocated module]


After identifying a process for injection, such as explorer.exe, the malware searches through the existing processes by using the following API calls:
CreateToolhelp32Snapshot
Process32First
Process32Next
OpenProcess

Each of these API calls exists because they can be and are used for many valid purposes and are commonly employed as such. 


For example:
GetUserName and GetComputerName are frequently and benignly used to obtain the current context in which a program is running. A piece of malware could use it for information gathering on a newly exploited system. FindExecutable is used to obtain the path to a Windows binary that a process relies on as a dependency.GetTempPath is used to enable one-off filesystem operations performed by processes, and is also a way for malware to create and hide its on-disk activity.The function CheckKeyboardBuffer could be used by normal software to determine whether an expected key was pressed, or it could be used by a piece of malware to peek at what is being typed. 

Some of the specific API calls used by the Cerber malware were used to selectively determine if the malware infected a particular machine. The relevant API calls are described below (and are available in the Help Viewer on cda-flare).

GetKBCodePage returns the Original Equipment Manufacturer (OEM) code-page identifier that specifies the manufacturing origin and likely keyboard layout.

GetLocaleInfoW returns identifiers that indicate the region and language options specified in the control panel.

(.exe)=import
DLL=export

############## mod 9 lesson 1 ##################
################ Registry ################### 

IMAGE SAVED : M9L1REGISTRY
IMAGE SAVED : M9L1datatypes
IMAGE SAVED : M9L1rootkey
IMAGE SAVED : M9L1HKCU_subkey
IMAGE SAVED : M9L1HKLM_subkeys
IMAGE SAVED : M9L1inicators
IMAGE SAVED : 
IMAGE SAVED : 

There are many registry events that occur each minute. Most of these query current settings by the system and other applications. It is generally unfeasible to monitor all registry events, or even all registry edit, change, delete, and add events. A targeted approach is more effective, but may miss IOCs for unknown threats. It is important for analysts and defenders to carefully tune any monitoring of registry events to the operating environment and threat level. Some of the important registry keys are discussed in this lesson. Specifically any registry key that is used to affect automatic execution, run on login, change in services, browser helper objects, File Explorer shell extensions, scheduled tasks, and drivers, among others, are some of the critical keys to be aware of and tune monitoring as threats dictate. The Windows Sysinternals Autoruns tool searches through many of these locations and registry keys and is used to assist in monitoring and detecting changes to the baseline configuration set by an organization. System Monitor (Sysmon) and Process Monitor (Procmon) are other tools in the Sysinternals suite used interactively and in unattended modes to monitor for these types of changes, but require tuning and filtering to not overload logging.

Techniques ###############

The MITRE ATT&CK framework details the following techniques specifically associated with the Windows registry:

T1012 Query Registry: Through a variety of tools, threat groups access the registry to query for system configuration data to include security credentials, users, permissions, antivirus or host intrusion detection/protection software, and other system profiling data

T1112 Modify Registry: Through a variety of methods, threat groups interact with the Windows registry to hide configuration information within registry keys, remove information as part of cleaning up, or as part of other techniques to aid in persistence and execution

T1552.002 Unsecured Credentials: Credentials in Registry: Threat groups search the registry on compromised systems for insecurely stored credentials

T1574.001 Boot or Logon Autostart Execution: Registry Run Keys/Startup Folder: Threat groups modify the registry to achieve persistence by adding a program to a startup folder or referencing it with a registry run key

T1574.011 Hijack Execution Flow: Services Registry Permissions Weakness: Threat groups execute their own malicious payloads by hijacking the registry entries used by services, use flaws in the permissions for registry to redirect from the originally specified executable to one that they control, in order to launch their own code at service start, and change local service configuration information in the registry

Mitigations ############ 

The key mitigation MITRE ATT&CK has identified is to restrict the registry permissions so that specific permissions are required to modify certain hives or keys in the registry. This is not an absolute mitigation as threat groups often use privilege escalation techniques to gain execution as a user that can modify those restricted keys. Monitoring is essential for critical keys to identify MCA.

M1024 Restrict Registry Permissions: Restrict the ability to modify certain hives or keys in the Windows registry


Registry Description ##############

The registry is a vital piece of Windows systems and holds the vast majority of configuration data for the Operating System (OS) and applications. It includes settings for the system and for each user. Registry data is read during the following principal events:

Initial boot: The boot loader reads the list of boot device drivers to load into memory

Kernel boot: The kernel reads settings that specify which device drivers to load and settings for other subsystems (memory manager, process manager, etc.)

Log on: During a user’s log on, File Explorer reads per-user settings from the registry (includes drive-letter mappings, wallpaper, screensaver, desktop appearance, etc.)

Application startup: Applications read systemwide and per-user settings during startup (can include licenses, menu and toolbar settings, recent documents, and other application settings)

the HKU root key contains the profile settings for all users with a profile on the current system, based on their Security Identifier (SID). There is also a subkey for DEFAULT, which is used for processes running under the local system account.

a user logs into the system for the first time and does not have a roaming profile, a profile is created for them based on the profile stored in the %SystemDrive%\Users\Default directory.

The HKCU root key is a link to the currently logged-in user’s SID key in the HKU root key. It is located on the hard disk at \Users\<username>\Ntuser.dat (older versions of Windows stored user profile information in \Documents and Settings\<username>\NTUSER.dat).

The registry keys HKCU\SOFTWARE\Microsoft\CurrentVersion\Run and HKCU\SOFTWARE\Microsoft\CurrentVersion\RunOnce hold values that indicate commands that should be run when that user logs in. The most common registry keys associated with this behavior are listed below. This list includes the keys that are applied to all users — HKLM — and the ones associated with the current user — HKCU.

HKLM\Software\Microsoft\Windows\CurrentVersion\Run
HKCU\Software\Microsoft\Windows\CurrentVersion\Run
HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnce
HKCU\Software\Microsoft\Windows\CurrentVersion\RunOnce
HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnceEx (not created by default on Windows Vista and newer, but can be created by MCAs or system administrators)
HKCU\Software\Microsoft\Windows NT\CurrentVersion\Run (legacy; older versions of Windows)

By default, the value of a RunOnce key is deleted before the command is run. If the value name is prefixed with an exclamation point (!), the deletion is deferred until after the command runs. If the value name is prefixed with an asterisk (*), the program starts in Safe mode, which is not the default. These registry keys reference the programs to run directly or as a dependency (e.g., depend on a .dll to load: HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnceEx\0001\Depend with the value C:\Users\trainee\bad.dll). The following list shows registry keys used to set Startup folder items for persistence:

HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders
HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders
HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders
HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders

The following list shows registry keys used to control automatic startup of services during boot:

HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\RunServicesOnce
HKCU\Software\Microsoft\Windows\CurrentVersion\RunServicesOnce
HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\RunServices
HKCU\Software\Microsoft\Windows\CurrentVersion\RunServices

Policy settings can be set to specify startup programs in these registry keys:

HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run
HKCU\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run

Custom actions can be added to the Winlogon key to add additional actions that occur on a computer system running Windows 7 and later:

HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\Userinit
HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\Shell

Run the following commands to create a new registry key, copy a value from one key to another key, verify the changes, and remove the copy: next 5 commands

New-Item -path Registry::HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce

Copy-ItemProperty -Path Registry::HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Run -name OneDrive -Destination Registry::hkcu\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce

Get-ItemProperty -Path Registry::HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce

Remove-Item -path Registry::HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce

Get-ItemProperty -Path Registry::HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce :  second Get-ItemProperty command verifies that the key was removed and shows an error message.

The registry entries under the SAM, SECURITY, and BCD keys are modified and changed with specific tools and applications within Windows in order to limit and prevent accidental or intentional configuration changes that may make the system unusable.

Changes that an attacker may make can be detected by watching for changes to the HKLM\SAM\SAM\DOMAINS\Account\Users\Names\<accountname> keys (Sysmon Event Identifier [ID] 12). Validating when new users are added and changes to the Local Administrators group (HKLM\SAM\SAM\Domains\Builtin\Aliases\0000220\) can identify rogue accounts and MCA (Sysmon Event ID 13). 

The HKLM\SYSTEM key stores system-wide security policies and user-rights assignments and is linked to the HKLM\SAM keys. Both of these keys and their subkeys can be seen in regedit in the SYSTEM account context, but the information is not very useful as it is not in a format meant to be read and understood by humans and is mostly undocumented. The subkeys HKLM\SYSTEM\ControlSet001 and HKLM\SYSTEM\CurrentControlSet refer to specific Windows settings where CurrentControlSet is the currently running settings and not necessarily saved to ControlSet001 (or other number for multiple control sets).

Invoke-Command cmdlet uses the capabilities of PowerShell to run commands on remote systems and takes advantage of the domain trust relationship for authentication. The system to run the command on is specified by -ComputerName cda-dc with the logon credentials supplied from the variable saved by the Get-Credential cmdlet in Step 9. The actual command to execute is enclosed in braces ({…}) and is the same command run locally to retrieve the profile list from the registry.


Since cda-hr-1 is a part of the cda.corp domain, the trust relationship allows the remote access using PowerShell without any additional configuration. From a non-domain member computer, there may be additional configuration requirements to use PowerShell for remote management.



############## mod 9 lesson 2 ##################
################ Services ################### 










































