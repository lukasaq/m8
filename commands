############## mod 8 lesson 1 ##################
################ Libraries ################### 

Get-Process explorer : Query for the explorer process
(Get-Process explorer).Modules : To view the loaded modules for the explorer process,

Run the following commands to find the processes for the specified module:
$processes = Get-Process
foreach($process in $processes) {
 foreach($module in $process.Modules){
  if ($module.ModuleName -eq 'advapi32.dll'){
   $process
  }
 }
}


$credentials = Get-Credential : Run the following command to store the credentials for the remote computer
Invoke-Command -Credential $credentials -ComputerName 'cda-dc' -ScriptBlock {Get-Process} : Use Invoke-Command to query the currently running processes on the remote computer
$processes = Invoke-Command -Credential $credentials -ComputerName 'cda-dc' -ScriptBlock {Get-Process} : further analyze the processes, use the following command to copy the collection locally

Enter the following commands to filter the processes for specific loaded modules

foreach($process in $processes) {
 foreach($module in $process.Modules){
  if ($module -like '*advapi32.dll*'){
   $process
  }
 }
}

Compiling and Executing a Library for AppInit_DLLs ##################

Compile the library using MinGW’s GNU Compiler Collection (GCC
gcc -shared -o dllmain.dll dllmain.cpp : Compile the library using MinGW’s GNU Compiler Collection (GCC):

GCC is executed using the following parameters:
- shared: Indicates output should be a shared library
- o: Indicates the path to the output file (dllmain.dll in this case)
- unnamed parameters: Input files to be used (dllmain.cpp in this case)

Detection #######################

the following PowerShell commands determine if the current system is configured with AppInit DLLs:
Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows" -Name "LoadAppInit_DLLs"
Get-ItemProperty -Path "HKLM:\SOFTWARE\Wow6432Node\Microsoft\Windows NT\CurrentVersion\Windows" -Name "LoadAppInit_DLLs"

from before, If any of these commands returns a 1, then the system is configured to use AppInit. The library or libraries loaded are discerned via:
Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows" -Name "AppInit_DLLs"

############## mod 8 lesson 2 ##################
################ Libraries ################### 

taskkill /PID 4376 /F : kills task base of pid
taskkill /IM notepad.exe /F : kills task base off of process name


Get-Process -name "firefox"
Get-Process -id 252
Get-Process -name exp*,pow*
Stop-Process -name firefox
Start-Process -FilePath "notepad.exe"
Stop-Process -id 212
Get-Process -name powershell -IncludeUserName

Run the following command to see which parent process ID spawns the running processes
important : Get-CimInstance -Class Win32_Process | Select-Object ProcessId,ProcessName,ParentProcessId

Print the WMI object for the powershell.exe process with the command
Get-CimInstance -class Win32_Process -filter "name = 'powershell.exe'" | Format-List *

Use the WMI GetOwner method with the command
Get-CimInstance -class Win32_Process -filter "name = 'powershell.exe'" | Invoke-CimMethod -MethodName GetOwner | Format-List *


invoke-command cda-acct-1, cda-acct-2, cda-acct-3 -scriptblock {get-process powershell -module}


Get-ciminstance -class win32_process -filter "name = 'powershell.exe'" -computername cda-acct-1 | select processname, processid, 
parentprocessid


Get-ciminstance -class win32_process -filter "processid = '2872'" -computer cda-acct-1 | select processname, processid


Get-ciminstance -class win32_process -filter "name = 'powershell.exe'" -computername cda-acct-1 | format-list *


invoke-command -computername cda-acct-1 -scriptblock {get-process -name powershell -includeusername}


invoke-command -computername cda-acct-1 -scriptblock {(get-process -name powershell -includeusername).username}

############## mod 8 lesson 3 ##################
################ Windows API ################### 

tasklist /fi "imagename eq explorer.exe" /m : List all libraries loaded for the explorer.exe process
tasklist /s 172.16.3.2 /u Administrator /fi "imagename eq wmiprvse.exe" /m : List all libraries loaded for the wmiprvse.exe process on a remote computer
Get-Process “explorer” | Select-Object -ExpandProperty Modules -ErrorAction SilentlyContinue | Format-Table -Autosize :  view DLLs loaded by the explorer.exe process on the local machine,
listdlls -h : pen the help menu for the utility with the command

List all DLLs loaded by cmd.exe with the following command
listdlls cmd
listdlls -r cmd

List all processes that have loaded the DLL advapi32.dll with the following command:
listdlls -d advapi32.dll | more


############## mod 9 lesson 1 ##################
################ Registry ################### 

 Get-ChildItem -Path Registry::HKEY_Current_User : get path
 Get-ItemProperty -Path : is used for registry keys to return the values for that key

Get-ChildItem -Path Registry::HKCU : cmdlet to list the registry keys under the HKCU root key:
Get-ItemProperty -PATH Registry::HKCU\Environment : Query the HKCU\Environment key
Get-ItemProperty -PATH Registry::HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Run | select * -Exclude PS* : Query the HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Run key


Get-ChildItem -Path Registry::HKLM\SYSTEM\CurrentControlSet\Enum\USBSTOR -Recurse : Query the HKLM\SYSTEM\CurrentControlSet\Enum\USBSTOR with the -Recurse option:
Get-ItemProperty -Path Registry::HKLM\SYSTEM\MountedDevices : Query the HKLM\SYSTEM\MountedDevices key:
Get-ChildItem -Path Registry::HKLM\SYSTEM\CurrentControlSet\Services : Query the HKLM\SYSTEM\CurrentControlSet\Services key:

powershell

Run the following commands to create a new registry key, copy a value from one key to another key, verify the changes, and remove the copy: next 5 commands

New-Item -path Registry::HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce

Copy-ItemProperty -Path Registry::HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Run -name OneDrive -Destination Registry::hkcu\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce

Get-ItemProperty -Path Registry::HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce

Remove-Item -path Registry::HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce

Get-ItemProperty -Path Registry::HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce :  second Get-ItemProperty command verifies that the key was removed and shows an error message.
powershell

command line
reg /? : Run the reg command with the help switch (/?)

The reg command has the following syntax:
reg (QUERY | ADD | DELETE | COPY | SAVE | LOAD | UNLOAD | RESTORE | COMPARE | EXPORT | IMPORT | FLAGS) [Parameter List]

reg query /? : following command to review the help for the query operation
reg query HKLM\Software\Microsoft\Windows\CurrentVersion\Run : following command to query the processes running
reg add HKLM\Software\Microsoft\Windows\CurrentVersion\Run /v test /t REG_SZ /d “c:\Windows\System32\notepad.exe” : following commands to add a value to a key and validate that it was added
reg query HKLM\Software\Microsoft\Windows\CurrentVersion\Run : check last command 

The following switches provide specific information:
/v: Value
/t: Data type
/d: Actual data to assign to the value
/f to force an overwrite of the existing value with the same name.

reg delete HKLM\Software\Microsoft\Windows\CurrentVersion\Run /v test : following command to delete the key, and enter Yes to the prompt
reg add HKLM\Software\Microsoft\Windows\CurrentVersion\Run\test : Run the following command to add a subkey
Run the following commands to delete the subkey and verify it was deleted next 2 commands
reg delete HKLM\Software\Microsoft\Windows\CurrentVersion\Run\test
reg query HKLM\Software\Microsoft\Windows\CurrentVersion\Run
notice now there are onlt 2 and test was deleted
command line

powershell
Get-Help Get-ItemProperty : help for the command let
Get-ItemProperty -Path HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run :  following command to query the value of the Run key

Run the following commands to add a registry value and verify: next 2 commands
Set-ItemProperty -path 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run' -Name 'test' -value 'C:\Windows\System32\notepad.exe'
Get-ItemProperty -path HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run

Run the following commands to change test value to calc.exe from notepad.exe from pervious 2 command: next 2 commands
Set-ItemProperty -path 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run' -Name 'test' -value 'C:\Windows\System32\calc.exe'
Get-ItemProperty -path HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run 

Run the following commands to rename the test value to test2 and verify: next 2 commands
Rename-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run' -Name 'test' -NewName 'test2'
Get-ItemProperty -path HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run

Run the following commands to delete the test2 value and verify deletion: next 2 commands
Remove-ItemProperty -path 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run' -Name 'test2'
Get-ItemProperty -path HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run
powershell

powershell

following command to prepare to store credentials in a variable ($cred) for use in an upcoming remote command:
$cred=Get-Credential

following command to execute a remote command to query the ProfileList key on cda-dc — 174.16.1.6
Invoke-Command -ComputerName cda-dc -Credential $cred -Command {Get-ItemProperty -Path 'Registry::HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList'}

Invoke-Command cmdlet uses the capabilities of PowerShell to run commands on remote systems and takes advantage of the domain trust relationship for authentication. The system to run the command on is specified by -ComputerName cda-dc with the logon credentials supplied from the variable saved by the Get-Credential cmdlet in Step 9. The actual command to execute is enclosed in braces ({…}) and is the same command run locally to retrieve the profile list from the registry.


Since cda-hr-1 is a part of the cda.corp domain, the trust relationship allows the remote access using PowerShell without any additional configuration. From a non-domain member computer, there may be additional configuration requirements to use PowerShell for remote management.

powershell


############## mod 9 lesson 2 ##################
################ Services ################### 





































































































