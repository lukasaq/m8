############## mod 8 lesson 1 ##################
################ Libraries ################### 

image saved m8l1_1

libraries are resources that contain code and/or data.
Libraries are referenced by new programs via a process known as linking. Libraries are linked statically or dynamically. Static linking copies all the referenced portions of the library into the resulting program image, while dynamic linking references the library instead of copying the library.


On Windows, libraries that are intended to be statically linked use the .lib file extension by convention. Linux prepends these files with lib and the file ending with .a. Since static libraries are copied to, and included in, the resulting binary at compile time, updating these libraries generally requires recompiling the program.


On Windows, dynamic libraries use the .dll file extension by convention; Linux uses .so. These libraries are stored externally to the application, so they can be updated independently of the executable that uses them.

On Windows, dynamic libraries can be found in various places. Libraries shared by multiple applications might exist in a specific shared library, like an installation in C:\Program Files\ or by convention by the library provider.
Libraries are also found in an application’s directory or in Windows system folders like System32.

Windows systems, there are various readily available programs to view modules (libraries) loaded by processes including Process Explorer, Process Hacker, PowerShell’s Get-Process cmdlet, etc.

SafeSearch Order:
 Directory application is located in
System directory (typically C:\Windows\System32)
16-bit System directory (typically C:\Windows\System)
Windows directory (typically C:\Windows\)
Current working directory
Directories listed in PATH environment variable


Examining Libraries ##########################

Analyst toolkits include many tools for viewing and interacting with dynamic libraries. There are several classes of tools for analyzing libraries and executables, such as:
- Decompiler: Attempts to reconstruct a library or program executable into source code that can be compiled into the same assembly. May require formatting and relabeling code in order to be comprehensible.

- Portable Executable (PE) Header/Metadata Analyzer: Examines the headers and other structures of an assembly to reveal information about the assembly, such as its dependencies and extracting resources from the 
file.
- String Analyzer/Dumper: Dumps all strings contained in an assembly for analysis.
- Disassembler: Breaks down native libraries into readable assembly code for analyzing behavior of a library or executable.
- Hex Editor: Allows viewing and editing of raw binaries; displays data using hexadecimal. Often contains the ability to view binary as various data formats, such as strings or integers.

Attacks Involving Libraries #######################
MITRE Adversarial Tactics, Techniques, and Common Knowledge (ATT&CK) Framework ########################

MITRE lists many Techniques, Tactics, and Procedures (TTP) that attackers use libraries in order to execute. A selection of these TTPs is covered, or use MITRE ATT&CK Navigator to explore TTPs, including those that are not covered here.

Dynamic libraries are used to achieve an attacker’s goal, including:
- Persistence
- Privilege Escalation
- Defense Evasion

The following techniques are used to accomplish one or more of the above tactics:

T1546.10: Event Triggered Execution: AppInit DLLs
Causes a library to be loaded any time an application that references User32.dll is executed, which encompasses most applications — allowing persistence. DllMain entries are used to execute code under that application’s context, which potentially allows for privilege escalation.

T1055.001: Process Injection: DLL Injection
DLL Injection: Attach to another process, then load a specified library — triggering the execution of code under that process’s context. This allows for privilege

T1574.002: Hijack Execution Flow: DLL Side-Loading
DLL Side-Loading: Application manifest files describe the version of a library that is loaded. If this manifest is vague or imprecise, an attacker can exploit this weakness to load a malicious library instead of the intended library. This allows an attacker to gain persistence by hijacking a common process, some defense evasion by its nature of executing under a trusted process, and a potential for privilege escalation if the process has elevated permissions.

T1574.001: Hijack Execution Flow: DLL Search Order Hijacking
Hijack Execution Flow: DLL Load Order attack takes advantage of weaknesses in some applications and the order of paths those libraries are loaded from. An attacker creates a malicious DLL that replaces a DLL expected by the application and executes code under the context of that application, allowing the attacker to potentially become persistent, escalate privileges, or evade defenses.

T1574.006: Hijack Execution Flow: LD_PRELOAD
LD_PRELOAD: A shared library attack for Linux that allows an attacker to override which library loads when a process loads a specific library by setting the LD_PRELOAD environment variable 

Detection #######################

Detection for each of these techniques typically involves the detection of libraries being loaded from unusual locations. This behavior is not typically logged by default on modern OSs. The installation of monitoring software is often necessary to detect these attacks, however, some of these methods leave behind artifacts — especially if in current use for persistence — such as:

T1546.010: AppInit DLL
Registry entries, such as HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows\LoadAppInit_DLLs
Malicious library in the path it is loaded from

T1055.001: DLL Injection
Malicious library or libraries used during the attackLoaded by processes

T1574.002: DLL Side-Loading
Malicious library or libraries used during the attack in C:\Windows\WinSXS folder
Library manifests in C:\Windows\WinSXS folder

T1547.004: DLL Load Order
Malicious library in a search path

T1574.006: LD_PRELOAD
Malicious library used during the attack
Persistent environmental variable change to the LD_PRELOAD variable

Detection of currently loaded malicious libraries is accomplished by querying modules loaded by processes on the system and analyzing them. This requires baseline information about the system and other hosts within the organization.

############## mod 8 lesson 2 ##################
################ Libraries ################### 

 process is an executing program — typically based on the Portable Execution (PE) file format 

 process has numerous elements including:
- A private virtual memory space
- An executable program image
- Handles to kernel objects
- A security token
- A unique Process Identifier (PID)
- One or more threads to execute instructions

Windows, memory space is divided into an area that user-mode processes access and a second area that is used exclusively by the kernel and kernel processes. 

32-bit systems, each process is allocated 2 Gigabytes (GB) for its user-mode memory space while the kernel gets 2GB shared across all processes. In 64-bit systems, each process can theoretically be allocated Terabytes (TB) of user-mode memory space while the kernel also gets TBs of memory space across all processes.

Windows Memory Manager, part of the kernel space Executive, decides where each process’s data is mapped in the computer’s physical RAM, or if it is stored on the computer’s hard drive in a process known as Paging.

Paging is the process by which Windows stores infrequently accessed information for processes on a system’s hard drive — in what is known as a paging file


each process receives the same range of addresses within their private virtual memory space, processes are not guaranteed to use the same memory addresses within that private memory space each time they are run. Modern Windows processes take advantage of Address Space Layout Randomization (ASLR). ASLR is a security mechanism that instructs the Windows loader randomize the base memory address of executables and the position of libraries, heap, and the stack in a processes' address space. ASLR is primarily intended to defend against memory-based exploits like buffer overflows by eliminating an exploit’s ability to rely on hardcoded memory addresses. ASLR does not defeat memory based exploits or attacks, but increases the difficulty to reliably gain control of execution, reducing the likelihood of a successful attack.

stack is an area of memory determined at compile time, and is used as storage for temporary variables and functions used by a program. The heap, in contrast, is used to store data that is provided to the process at runtime because the developer cannot anticipate exactly what information is input into the program in advance. 

Notably, in the interest of being memory efficient, system Dynamic Link Libraries (DLL) are shared between processes and commonly mapped to the same locations in virtual memory. Notepad.exe and MicrosoftEdge.exe have the DLL urlmon.dll mapped to the same location,

Any action that involves interaction with a computer’s hardware requires assistance from the kernel. 

When a user logs into Windows, the system generates and associates a security token with that user account. Each process that user starts receives the security token, which includes the identity and privileges of the user account. 

Security tokens contain a range of information, such as the Security Identifier (SID) of the originating user account, the SIDs for the groups which the account is a member, and a list of privileges held by that user or that user’s groups.

Each process, when it is created, receives a unique PID. A PID can be used to locate a running process and create a handle to it, like a kernel object.

A thread has multiple components:
- Memory
- Execution contex
- Thread local storage
- Security token
- Message queue
- Thread ID
- State
- Priority

. Memory can also be dynamically allocated by a thread, which would be in the process’s heap; dynamic memory is shared between threads, while the stack memory is not.

TLS provides a mechanism for a thread to store data relevant only to it — without needing to share that information across other threads.

Like processes, threads also have unique IDs that other applications can use to identify specific threads and create handles pointing to them. A thread ID is only unique for as long as a thread exists; once a thread has finished executing, its ID is relinquished and can be reused by the system for a new thread.

Each thread has a state which represents whether it is currently executing instructions. For example, some states include Ready (meaning the thread is available for the OS to execute it), Standby (meaning the thread has been selected as the next thread to execute), Wait (meaning the thread is currently paused and waiting for an operation to complete or a resource to become free), and Running (meaning the thread is currently executing).


This process is responsible for enforcing security policy on the system, including logon verification, password policy, writing to Windows security logs, and the creation of access tokens. Credentials are often stored in lsass process memory for use by accounts during a login session. Since it contains those credentials, dumping lsass memory is a valued target of threat actors during the following types of attacks:
MITRE ATT&CK OS Credential Dumping: LSASS Memory T1003.001: https://attack.mitre.org/techniques/T1003/001/ MITRE ATT&CK Boot or Logon Autostart Execution: LSASS Driver T1547.008: https://attack.mitre.org/techniques/T1547/008/ MITRE ATT&CK Modify Authentication Process T1556: https://attack.mitre.org/techniques/T1556/ 


This application is used to launch functionality stored in shared DLL files. The valid process is normally located at C:\Windows\System32\rundll32.exe, but sometimes malware uses the same filename and runs from a different directory in order to disguise itself, so determining the executable file path is important if this process is suspect. Additionally, threat actors may abuse the allowlists or false positives from normal operations associated with rundll32.exe to proxy execution of malicious code. By bootstrapping a shared module through rundll32.exe, instead of executing directly, they may avoid defensive mechanism on a system. This method is described further in MITRE technique ID T1218.011 Signed Binary Proxy Execution: Rundll32.


Additional Resources
MITRE ATT&CK Signed Binary Proxy Execution: Rundll32: https://attack.mitre.org/techniques/T1218/011/ MITRE ATT&CK Masquerading: Match Legitimate Name or Location: https://attack.mitre.org/techniques/T1036/005/

############## mod 8 lesson 3 ##################
################ Windows API ################### 

Windows API is the intermediary interface that allows other programs to interact with the Windows OS. It can be used for many things such as manipulating or creating processes, modifying the registry, and enabling network connections. It can be thought of as a collection of predefined functions to do everything that needs to be done within the OS. Each function has specific input requirements and produces specific outputs, but how the function actually performs its task is not publicly documented by the Windows developers


 functions that make up the Windows API — and are used to communicate with the Windows OS — are stored and accessed via Windows library files known as DLLs, which can be grouped into categories, some of which are explained below. Full documentation can be found in the Microsoft documentation. 

System Services: These libraries provide access to Windows file systems, devices, processes and threads, registry, and error handling.Library DLLs:kernel32.dll advapi32.dll ole32.dll

Graphics Device Interface: These libraries provide the functionality for outputting graphical content to monitors, printers, and other output devices.Library DLLs:gdi32.dll

User Interface (UI): These libraries include Common Dialog Box DLLs, which provide functions to create and interface with standard dialog boxes for opening and saving files, choosing color and font, etc.; Common Control Library DLLs, which provide access to status bars, progress bars, toolbars, tabs, and other advanced control features; and Windows Shell DLLs, which provide the functionality and modification of the OS shell.Library DLLs:comctl32.dllcomdlg32.dllshell32.dll  shlwapi.dlluser32.dll

Network Services: These libraries provide access to the various networking capabilities of the OS, including Network Basic Input/Output System (NetBIOS), Windows Sockets (Winsock), Network Dynamic Data Exchange (NetDDE), Remote Procedure Calls (RPC), and many others.Library DLLs:ws2_32.dllwsock32.dllwininet.dllnetapi32.dll

Kernel32.dll: This is a very common DLL that contains core functionality, such as access and manipulation of memory, files, and hardware. Some of the common API calls in this DLL are:
ConnectNamedPipe: Creates a server pipe for interprocess communication that waits for a client pipe to connect. Some backdoors and reverse shells use ConnectNamedPipe to simplify or obfuscate connectivity to a Command and Control (C2) server.
CreateFile: Creates a new file or opens an existing file.
CreateFileMapping: Creates a handle to a file mapping that loads a file into memory and makes it accessible via memory addresses. Launchers, loaders, and injectors use this to read and modify PE files.CreateProcess: Creates and launches a new process. If malware creates a new process, it needs to be analyzed as well.
CreateRemoteThread: Starts a thread in a remote process. Launchers and stealth malware use CreateRemoteThread to inject code into a different process.
numProcesses: Enumerates through running processes on the system. Malware enumerates through processes to find one into which to inject.
EnumProcessModules: Enumerates the loaded modules (executables and DLLs) for a given process. Malware enumerates through modules when performing an injection
GetModuleFilename: Returns the filename of a module loaded in the current process. Malware uses this function to modify or copy files in the currently running process.
GetModuleHandle: Obtains a handle to an already loaded module. Processes use GetModuleHandle to locate and modify code in a loaded module or to search for a good location to inject code.
GetProcAddress: Retrieves the address of a function in a DLL loaded into memory. Imports functions from other DLLs and functions imported in the PE file header.
IsWoW64Process: Used by a 32-bit process to determine if it is running on a 64-bit OS.
LoadLibraryA/LoadLibraryEx: Function to load a DLL into a process.
OpenProcess: Opens a handle to another process running on the system. This handle reads and writes to the other process memory or injects code into the other process.
SetFileTime: Modifies the creation, access, or last modified time of a file. Malware often uses this function to conceal malicious activity.
VirtualAllocEx: A routine that allocates memory in a remote process. Malware uses VirtualAllocEx as part of a process injection.
WriteProcessMemory: Writes data to a remote process. Malware uses WriteProcessMemory as part of a process injection.

Advapi32.dll: This DLL provides access to advanced Windows core components, such as Service Manager and the registry. Some of the common API calls in this DLL are:
AdjustTokenPrivileges: Enables/disables specific access privileges. It allows malware to gain additional permissions in a process injection attack.
ControlService: Starts, stops, modifies, or sends a signal to a running service. Code needs to be analyzed that implements malicious services in order to determine the purpose of the call.
CreateService: Creates a service started at boot time. Malware uses CreateService for persistence, stealth, or to load kernel drivers.
RegCreateKeyEx: Creates a registry key.
RegDeleteKey: Deletes a registry subkey and its values.

WSock32.dll and Ws2_32.dll: These are networking DLLs. A program that accesses either of these most likely connects to a network or performs network-related tasks. Some of the common API calls in this DLL are:
Accept: Listens for incoming connections on a socket. Used by malware to communicate with the C2 server.
Bind: Associates a local address to a socket to listen for incoming connections.
Connect: Connects to a remote socket. Malware often uses low-level functionality to connect to a C2 server. Used by malware to communicate with the C2 server.
inet_addr: Converts an Internet Protocol (IP) address string  — like 127.0.0.1 — to the Windows structure used by other functions, such as Connect. The IP addresses found in these calls — and used in malware —  may be used in network-based signatures to identify potentially malicious activity. 
Recv: Receives data from a remote machine. Used by malware to receive data from a remote C2 server.
Send: Sends data to a remote machine. Used by malware to send data to a remote C2 server.
WSAStartup: Initializes low-level network functionality. Finding calls to WSAStartup is an easy way to locate the start of network-related functionality.

Wininet.dll: This DLL contains higher-level networking functions that implement protocols such as File Transfer Protocol (FTP), Hypertext Transfer Protocol (HTTP), and Network Time Protocol (NTP). Some of the common API calls in this DLL are:
FtpPutFile: Uploads a file to remote FTP server.
InternetOpen: Initializes the high-level internet access functions from Windows Internet (WinINet), such as InternetOpenUrl and InternetReadFile. Searching for InternetOpen is a good way to find the start of internet access functionality. One of the parameters to InternetOpen is the UserAgent, which may be a good network-based signature, if it is unique or not common.
InternetOpenUrl: Opens a specific Uniform Resource Locator (URL) for a connection using FTP, HTTP, or Hypertext Transfer Protocol Secure (HTTPS). URLs, if fixed, may be good network-based signatures.
InternetReadFile: Reads data from a previously opened URL.
InternetWriteFile: Writes data to a previously opened URL.

Ntdll.dll: The interface to the Windows kernel. Importing this DLL is one way that one can gain access to the undocumented Windows Native API.



 The -r option is normally identical to the normal output as seen in Figure 8.3-15. The output changes if the DLL is loaded from a relocated module — below is an example of what would change in the listdlls output:

 ### Relocated from base of 0x00000000a8270000:
 [base] [size] [path of relocated module]


After identifying a process for injection, such as explorer.exe, the malware searches through the existing processes by using the following API calls:
CreateToolhelp32Snapshot
Process32First
Process32Next
OpenProcess

Each of these API calls exists because they can be and are used for many valid purposes and are commonly employed as such. 


For example:
GetUserName and GetComputerName are frequently and benignly used to obtain the current context in which a program is running. A piece of malware could use it for information gathering on a newly exploited system. FindExecutable is used to obtain the path to a Windows binary that a process relies on as a dependency.GetTempPath is used to enable one-off filesystem operations performed by processes, and is also a way for malware to create and hide its on-disk activity.The function CheckKeyboardBuffer could be used by normal software to determine whether an expected key was pressed, or it could be used by a piece of malware to peek at what is being typed. 

Some of the specific API calls used by the Cerber malware were used to selectively determine if the malware infected a particular machine. The relevant API calls are described below (and are available in the Help Viewer on cda-flare).

GetKBCodePage returns the Original Equipment Manufacturer (OEM) code-page identifier that specifies the manufacturing origin and likely keyboard layout.

GetLocaleInfoW returns identifiers that indicate the region and language options specified in the control panel.

(.exe)=import
DLL=export











































