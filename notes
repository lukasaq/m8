############## mod 8 lesson 1 ##################
################ Libraries ################### 

image saved m8l1_1

libraries are resources that contain code and/or data.
Libraries are referenced by new programs via a process known as linking. Libraries are linked statically or dynamically. Static linking copies all the referenced portions of the library into the resulting program image, while dynamic linking references the library instead of copying the library.


On Windows, libraries that are intended to be statically linked use the .lib file extension by convention. Linux prepends these files with lib and the file ending with .a. Since static libraries are copied to, and included in, the resulting binary at compile time, updating these libraries generally requires recompiling the program.


On Windows, dynamic libraries use the .dll file extension by convention; Linux uses .so. These libraries are stored externally to the application, so they can be updated independently of the executable that uses them.

On Windows, dynamic libraries can be found in various places. Libraries shared by multiple applications might exist in a specific shared library, like an installation in C:\Program Files\ or by convention by the library provider.
Libraries are also found in an application’s directory or in Windows system folders like System32.

Windows systems, there are various readily available programs to view modules (libraries) loaded by processes including Process Explorer, Process Hacker, PowerShell’s Get-Process cmdlet, etc.

SafeSearch Order:
 Directory application is located in
System directory (typically C:\Windows\System32)
16-bit System directory (typically C:\Windows\System)
Windows directory (typically C:\Windows\)
Current working directory
Directories listed in PATH environment variable


Examining Libraries ##########################

Analyst toolkits include many tools for viewing and interacting with dynamic libraries. There are several classes of tools for analyzing libraries and executables, such as:
- Decompiler: Attempts to reconstruct a library or program executable into source code that can be compiled into the same assembly. May require formatting and relabeling code in order to be comprehensible.

- Portable Executable (PE) Header/Metadata Analyzer: Examines the headers and other structures of an assembly to reveal information about the assembly, such as its dependencies and extracting resources from the 
file.
- String Analyzer/Dumper: Dumps all strings contained in an assembly for analysis.
- Disassembler: Breaks down native libraries into readable assembly code for analyzing behavior of a library or executable.
- Hex Editor: Allows viewing and editing of raw binaries; displays data using hexadecimal. Often contains the ability to view binary as various data formats, such as strings or integers.

Attacks Involving Libraries #######################
MITRE Adversarial Tactics, Techniques, and Common Knowledge (ATT&CK) Framework ########################

MITRE lists many Techniques, Tactics, and Procedures (TTP) that attackers use libraries in order to execute. A selection of these TTPs is covered, or use MITRE ATT&CK Navigator to explore TTPs, including those that are not covered here.

Dynamic libraries are used to achieve an attacker’s goal, including:
- Persistence
- Privilege Escalation
- Defense Evasion

The following techniques are used to accomplish one or more of the above tactics:

T1546.10: Event Triggered Execution: AppInit DLLs
Causes a library to be loaded any time an application that references User32.dll is executed, which encompasses most applications — allowing persistence. DllMain entries are used to execute code under that application’s context, which potentially allows for privilege escalation.

T1055.001: Process Injection: DLL Injection
DLL Injection: Attach to another process, then load a specified library — triggering the execution of code under that process’s context. This allows for privilege

T1574.002: Hijack Execution Flow: DLL Side-Loading
DLL Side-Loading: Application manifest files describe the version of a library that is loaded. If this manifest is vague or imprecise, an attacker can exploit this weakness to load a malicious library instead of the intended library. This allows an attacker to gain persistence by hijacking a common process, some defense evasion by its nature of executing under a trusted process, and a potential for privilege escalation if the process has elevated permissions.

T1574.001: Hijack Execution Flow: DLL Search Order Hijacking
Hijack Execution Flow: DLL Load Order attack takes advantage of weaknesses in some applications and the order of paths those libraries are loaded from. An attacker creates a malicious DLL that replaces a DLL expected by the application and executes code under the context of that application, allowing the attacker to potentially become persistent, escalate privileges, or evade defenses.

T1574.006: Hijack Execution Flow: LD_PRELOAD
LD_PRELOAD: A shared library attack for Linux that allows an attacker to override which library loads when a process loads a specific library by setting the LD_PRELOAD environment variable 

Detection #######################

Detection for each of these techniques typically involves the detection of libraries being loaded from unusual locations. This behavior is not typically logged by default on modern OSs. The installation of monitoring software is often necessary to detect these attacks, however, some of these methods leave behind artifacts — especially if in current use for persistence — such as:

T1546.010: AppInit DLL
Registry entries, such as HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows\LoadAppInit_DLLs
Malicious library in the path it is loaded from

T1055.001: DLL Injection
Malicious library or libraries used during the attackLoaded by processes

T1574.002: DLL Side-Loading
Malicious library or libraries used during the attack in C:\Windows\WinSXS folder
Library manifests in C:\Windows\WinSXS folder

T1547.004: DLL Load Order
Malicious library in a search path

T1574.006: LD_PRELOAD
Malicious library used during the attack
Persistent environmental variable change to the LD_PRELOAD variable

Detection of currently loaded malicious libraries is accomplished by querying modules loaded by processes on the system and analyzing them. This requires baseline information about the system and other hosts within the organization.

############## mod 8 lesson 2 ##################
################ Libraries ################### 

 process is an executing program — typically based on the Portable Execution (PE) file format 

 process has numerous elements including:
- A private virtual memory space
- An executable program image
- Handles to kernel objects
- A security token
- A unique Process Identifier (PID)
- One or more threads to execute instructions

Windows, memory space is divided into an area that user-mode processes access and a second area that is used exclusively by the kernel and kernel processes. 

32-bit systems, each process is allocated 2 Gigabytes (GB) for its user-mode memory space while the kernel gets 2GB shared across all processes. In 64-bit systems, each process can theoretically be allocated Terabytes (TB) of user-mode memory space while the kernel also gets TBs of memory space across all processes.

Windows Memory Manager, part of the kernel space Executive, decides where each process’s data is mapped in the computer’s physical RAM, or if it is stored on the computer’s hard drive in a process known as Paging.

Paging is the process by which Windows stores infrequently accessed information for processes on a system’s hard drive — in what is known as a paging file


each process receives the same range of addresses within their private virtual memory space, processes are not guaranteed to use the same memory addresses within that private memory space each time they are run. Modern Windows processes take advantage of Address Space Layout Randomization (ASLR). ASLR is a security mechanism that instructs the Windows loader randomize the base memory address of executables and the position of libraries, heap, and the stack in a processes' address space. ASLR is primarily intended to defend against memory-based exploits like buffer overflows by eliminating an exploit’s ability to rely on hardcoded memory addresses. ASLR does not defeat memory based exploits or attacks, but increases the difficulty to reliably gain control of execution, reducing the likelihood of a successful attack.

stack is an area of memory determined at compile time, and is used as storage for temporary variables and functions used by a program. The heap, in contrast, is used to store data that is provided to the process at runtime because the developer cannot anticipate exactly what information is input into the program in advance. 

Notably, in the interest of being memory efficient, system Dynamic Link Libraries (DLL) are shared between processes and commonly mapped to the same locations in virtual memory. Notepad.exe and MicrosoftEdge.exe have the DLL urlmon.dll mapped to the same location,

Any action that involves interaction with a computer’s hardware requires assistance from the kernel. 

When a user logs into Windows, the system generates and associates a security token with that user account. Each process that user starts receives the security token, which includes the identity and privileges of the user account. 

Security tokens contain a range of information, such as the Security Identifier (SID) of the originating user account, the SIDs for the groups which the account is a member, and a list of privileges held by that user or that user’s groups.

Each process, when it is created, receives a unique PID. A PID can be used to locate a running process and create a handle to it, like a kernel object.

A thread has multiple components:
- Memory
- Execution contex
- Thread local storage
- Security token
- Message queue
- Thread ID
- State
- Priority

. Memory can also be dynamically allocated by a thread, which would be in the process’s heap; dynamic memory is shared between threads, while the stack memory is not.

TLS provides a mechanism for a thread to store data relevant only to it — without needing to share that information across other threads.

Like processes, threads also have unique IDs that other applications can use to identify specific threads and create handles pointing to them. A thread ID is only unique for as long as a thread exists; once a thread has finished executing, its ID is relinquished and can be reused by the system for a new thread.

Each thread has a state which represents whether it is currently executing instructions. For example, some states include Ready (meaning the thread is available for the OS to execute it), Standby (meaning the thread has been selected as the next thread to execute), Wait (meaning the thread is currently paused and waiting for an operation to complete or a resource to become free), and Running (meaning the thread is currently executing).


This process is responsible for enforcing security policy on the system, including logon verification, password policy, writing to Windows security logs, and the creation of access tokens. Credentials are often stored in lsass process memory for use by accounts during a login session. Since it contains those credentials, dumping lsass memory is a valued target of threat actors during the following types of attacks:
MITRE ATT&CK OS Credential Dumping: LSASS Memory T1003.001: https://attack.mitre.org/techniques/T1003/001/ MITRE ATT&CK Boot or Logon Autostart Execution: LSASS Driver T1547.008: https://attack.mitre.org/techniques/T1547/008/ MITRE ATT&CK Modify Authentication Process T1556: https://attack.mitre.org/techniques/T1556/ 


This application is used to launch functionality stored in shared DLL files. The valid process is normally located at C:\Windows\System32\rundll32.exe, but sometimes malware uses the same filename and runs from a different directory in order to disguise itself, so determining the executable file path is important if this process is suspect. Additionally, threat actors may abuse the allowlists or false positives from normal operations associated with rundll32.exe to proxy execution of malicious code. By bootstrapping a shared module through rundll32.exe, instead of executing directly, they may avoid defensive mechanism on a system. This method is described further in MITRE technique ID T1218.011 Signed Binary Proxy Execution: Rundll32.


Additional Resources
MITRE ATT&CK Signed Binary Proxy Execution: Rundll32: https://attack.mitre.org/techniques/T1218/011/ MITRE ATT&CK Masquerading: Match Legitimate Name or Location: https://attack.mitre.org/techniques/T1036/005/

############## mod 8 lesson 3 ##################
################ Windows API ################### 



































































